#!/usr/bin/env python3
# List connected probes and update the list used by Ansible
# Run regularly from crontab to update the list
# Chris Gadd
# chris.gadd@vodafone.com
# 2017-04-21
# IPv4 only

import argparse
import json
import pathlib
import requests
import subprocess
import string
import shlex
import re
import sys
import yaml
from operator import itemgetter

# Location of Ansible inventory and variables
ansibleInventory = "/etc/ansible/hosts"
# Assuming this file is in amp/scripts, variables are in amp/ansible/vars/main.yml
directory = pathlib.Path(__file__).resolve().parent.parent
config = str(directory) + "/ansible/vars/main.yml"

# List of Ansible groups to create (group name followed by regex match)
# Used by Rundeck and CLI
ansibleGroups = yaml.load(open(config))['ansibleGroups']

parser = argparse.ArgumentParser(description="Display list of AMP probes and their IP addresses")
parser.add_argument("-u", '--update', help="Update list of probes/endpoints from AMP (must be run as root or \
					user who can switch to postgres user)", action='store_true')
parser.add_argument("-a", '--all', help="Display all probes (include endpoints). Use twice to also display \
					disconnected probes.", action='count')
parser.add_argument("-c", '--count', help="Display count only", action='store_true')
parser.add_argument("-d", '--disconnected', help="Display disconnected probes only", action='store_true')
parser.add_argument("-e", '--endpoints', help="Display endpoints only", action='store_true')
parser.add_argument("-m", '--match', help="Only display probes matching given text", action='append')
parser.add_argument("-n", '--number', help="Show probe numbers only", action='store_true')
args = parser.parse_args()
all = args.all
count = args.count
disconnected = args.disconnected
endpointsonly = args.endpoints
matchlist = args.match
update = args.update
number = args.number

def printProbe(hostname, ip, access, location, hardware, endpoint=''):
	# Print the probe details nicely
	if not count:
		if number:
			print(hostname + ',',end='')
		else:
			print("{:{}} {:16} {:13} {:18} {:10} {}".format(hostname, probewidth, ip, access, location, hardware, endpoint))

def parseDescription(description):
	# Extract components of the probe description to get useful fields
	# Tried to be a little flexible with regex to allow for badly formatted description field
	try:
		# 1st field
		hardware = re.search(r'^([^;]+)', description).group(1).strip()
	except AttributeError:
		hardware = ""
	try:
		# 2nd to last field
		endpoint = re.search(r'([^;]+);[^;]+$', description).group(1).strip()
	except AttributeError:
		endpoint = ""
	try:
		# last field
		staticIP = re.search(r'([^;]+)$', description).group(1).strip()
	except AttributeError:
		staticIP = ""
	return hardware, endpoint, staticIP

if update:
	# Update the Ansible inventory from the AMP web list
	print("Updating list of probes and endpoints...")
	# Login to server
	server = yaml.load(open(config))['ampweb']['server']
	baseURL = "https://" + server + "/"
	username = yaml.load(open(config))['ampweb']['user']
	password = yaml.load(open(config))['ampweb']['password']
	session = requests.Session()
	payload = {'username': username, 'password': password, 'login.submitted': ''}
	response = session.post(baseURL, data=payload)
	if "Incorrect username or password" in response.content.decode():
		sys.exit("Username or password invalid retrieving probe list")
	# Get probe list - from the 'probes' mesh
	url = baseURL + "api/v2/meshes/probes/sites"
	response = session.get(url)
	probeList = json.loads(response.content)["membership"]
	probeList = sorted(probeList, key=itemgetter("ampname"))
	# Get endpoint list - from any mesh starting with 'endpoints'
	url = baseURL + "api/v2/meshes"
	response = session.get(url)
	meshes = json.loads(response.content)['meshes']
	endpointList = []
	for mesh in meshes:
		if mesh['ampname'].startswith("endpoints"):
			url = baseURL + "api/v2/meshes/" + mesh["ampname"] + "/sites"
			response = session.get(url)
			thismesh = json.loads(response.content)["membership"]
			endpointList = endpointList + thismesh
	endpointList = sorted(endpointList, key=itemgetter("ampname"))

	# Create hosts file. Groups (probes,endpoints,others) followed by common variables
	with open(ansibleInventory, 'w') as f:
		f.write("# Generated by " + __file__ + "\n")
		f.write("[probes]\n")
		for site in probeList:
			hardware, endpoint, staticIP = parseDescription(site["description"])
			f.write('{} access="{}" location="{}" hardware="{}" endpoint="{}" staticIP="{}"\n'.format(
				site["ampname"], site["longname"], site["location"], hardware, endpoint, staticIP))
		f.write("[endpoints]\n")
		for site in endpointList:
			hardware, endpoint, staticIP = parseDescription(site["description"])
			f.write('{} access="{}" location="{}" hardware="{}" endpoint="{}" staticIP="{}"\n'.format(
				site["ampname"], site["longname"], site["location"], hardware, endpoint, staticIP))
		for groupname, groupinfo in ansibleGroups.items():
			# groupinfo is either just a regex match, or a list with regex followed by vars
			if type(groupinfo) == list:
				match = groupinfo[0]
				vars = groupinfo[1]
			else:
				match = groupinfo
				vars = None
			f.write("[" + groupname + "]\n")
			for site in (probeList + endpointList):
				attributes = "{} {} {} {}".format(site["ampname"], site["longname"], site["location"], site["description"])
				if re.search(str(match), attributes):
					f.write(site["ampname"] + "\n")
			if vars:
				f.write("[" + groupname + ":vars]\n" + vars + "\n")
	sys.exit()

print("Checking for connected probes...")
# make the output look nice (endpoint names are long)
probewidth = 45 if (all or endpointsonly) else 5

# Identify connected probes as those on TCP port 2xxx (user has sudo access to ss command)
portlist = subprocess.check_output(['sudo', 'ss', '-antp', 'sport == 22 or src 127.0.0.1']).decode('utf-8')
# output format is:
# LISTEN    0       128                127.0.0.1:2843               0.0.0.0:*      users:(("sshd",pid=61553,fd=10))
# ESTAB     0       0              203.0.113.145:22               192.0.2.5:51578  users:(("sshd",pid=61553,fd=3),("sshd",pid=60810,fd=3))

# display probes & endpoints
probesConnected = 0
probes = 0
endpoints = 0

with open(ansibleInventory) as f:
	for line in f:
		if "[probes]" in line:
			hosttype = "probe"
			continue
		elif "[endpoints]" in line:
			if all or endpointsonly:
				hosttype = "endpoint"
				continue
			else:
				# probes section comes first, so break out of loop if not showing the endpoints
				break
		elif line.startswith('#'):
			continue
		elif line.startswith('['):
			# additional groups, not interested
			break

		# Must be a host, start processing
		elements = shlex.split(line)
		hostname = elements[0]
		access = elements[1].split('=')[1]
		location = elements[2].split('=')[1]
		hardware = elements[3].split('=')[1]
		endpoint = elements[4].split('=')[1]
		staticIP = elements[5].split('=')[1]

		if hosttype == "probe" and not endpointsonly:
			# check for matches
			showprobe = True
			if matchlist:
				for match in matchlist:
					if not (match in hostname or match in access or match in location or match in hardware or match in endpoint):
						showprobe = False
			if showprobe:
				probes += 1
				# determine the process ID by finding whatever is listening on IPv4 localhost with port 2xxx
				regex = r'LISTEN\s+\d+\s+\d+\s+127.0.0.1:2' + hostname + r'\s+0.0.0.0:\*\s+users:\(\("sshd",pid=(\d+)'
				m = re.search(regex, portlist)
				if m:
					# probe connected
					pid = m.group(1)
					# find IP address using the process ID. It could be the 1st or 2nd PID in the output
					regex = r'ESTAB\s+\d+\s+\d+\s+\d+.\d+.\d+.\d+:\d+\s+(\d+.\d+.\d+.\d+):\d+\s+users:.*pid=' + str(pid) + r',fd'
					m = re.search(regex, portlist)
					if m and not disconnected:
						# found IP
						ip = m.group(1)
						probesConnected += 1
						# and print everything
						printProbe(hostname, ip, access, location, hardware, endpoint)
				elif (all == 2) or disconnected:
					# probe not connected
					printProbe(hostname, "disconnected", access, location, hardware, endpoint)

		elif hosttype == "endpoint":
			# check for matches
			showprobe = True
			if matchlist:
				for match in matchlist:
					if not (match in hostname or match in access or match in location or match in hardware):
						showprobe = False
			if showprobe:
				endpoints += 1
				# test connectivity. Use timeout command with ping to get sub-second answer
				try:
					response = subprocess.check_output(['timeout', '0.5', 'ping', '-c1', hostname]).decode('utf-8')
					ip = re.match(r'PING ' + re.escape(hostname) + ' \((.*?)\)', response).group(1)
				except subprocess.CalledProcessError:
					# failed (no response or unknown host)
					ip = "disconnected"
				# exclude connected endpoints if disconnected flag specified, otherwise show all
				if not (disconnected and ip != "disconnected"):
					printProbe(hostname, ip, access, location, hardware)

if all:
	print("\n{} connected probes of {} total plus {} endpoints".format(probesConnected, probes, endpoints))
elif endpointsonly:
	print("\n{} endpoints".format(endpoints))
else:
	print("\n{} connected probes of {} total".format(probesConnected, probes))
